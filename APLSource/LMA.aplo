 LMA←{⍺←⊢ ⋄ p←⊃w←⊆⍵ ⋄ 0::⎕SIGNAL ⎕EN                    ⍝ pass signals

     n←'d',¨'ini' 'inc' 'dec' 'max' 'min'               ⍝ damping
     n←('isrg',⍨¨⊂'tol'),n                              ⍝ tolerances
     nc←'ddec' 'dmin'                                   ⍝ computed defaults
     nr←'iter' 'ssr' 'rel' 'dnorm' 'p'                  ⍝ results
     c←(                                                ⍝ default config
         toli:1000 ⋄ tols:⎕CT ⋄ tolr:⎕CT ⋄ tolg:0.01    ⍝     tolerances
         dini:0.01 ⋄ dinc:5 ⋄ dmax:÷⎕CT                 ⍝     damping
         p0:p ⋄ dp:⎕CT ⋄ verbose:0                      ⍝     init guess, perturbation, logging
     )
     F←{1((⊂6 0⍕↑),12 ¯5∘⍕¨⍤↓)⍵} ⋄ P←{⎕←F ⍵ ⋄ ⍵}        ⍝ format and print
     D←{⍕'sp',¨':',¨(⊂2 5)⌷F ⍵}                         ⍝ display form
     J←{⍉↑⍺÷⍨(⍺⍺¨(⊂⍵)+↓↑(-⍳≢⍵)↑¨⍺)-⊆⍺⍺ ⍵}               ⍝ estimate Jacobian

     3=⎕NC'⍺⍺':⍺((⍺⍺{⍵.Eval←⍺⍺ ⋄ ⍵}c)∇∇)w               ⍝ ⍺⍺ is Eval function
     (1<≢w)∧~2|⎕DR⊃⌽w:⍺((⎕NS ⍺⍺(⊃⌽w))∇∇)¯1↓w            ⍝ non numeric extra argument is config
     2<≢w:⎕SIGNAL 11                                    ⍝ wrong argument

     c.CallBack←⊢ ⋄ c←c ⎕NS ⍺⍺ ⋄ c.dnorm←1⊣⍣(1=≢w)⊃⌽w   ⍝ default callback and actual config
     _←c ⎕VSET(↑nc)(c ⎕VGET(↑nc)c.(÷dinc dmax))         ⍝ computed defaults
     C←⍺{⍺⍺ c.CallBack c ⎕VSET(↑nr)⍵}P⍣(c.verbose≢0)    ⍝ callback function
     E←⍺∘c.Eval{(1<≡e)∧2=≢e←⍺⍺ ⍵:e ⋄ (⊃⊆e)(⍺ ⍺⍺ J ⍵)}   ⍝ eval function
     c⊣c.⎕DF D(c ⎕VGET↑n)(c.dp∘E)LM C p c.dnorm         ⍝ return namespace
 }
