 LM←{ti ts tr tg d0 di dd dx dn←⍺ ⋄ p d←⍵               ⍝ Levenberg–Marquardt algorithm

     D←((dx-d0)×dn-⍨⊢)÷(d0-dn)×dx-⊢ ⋄ L←1,⍨⊢,(×⍨1∘↑)    ⍝ damping factor normalization(λ) and standard loss(y)
     E←⍺⍺{y j l w←L⍣(2=≢g)⊢g←⍺⍺ ⍵ ⋄ (+/l)⍵ y j w}       ⍝ eval(p): sum(loss), parameters, residual, jacobian

     A←{s p y j w←⍵ ⋄ s p(t+.×j)(y+.×⍨t←w×⍤1⍉j)}        ⍝ accept(EG output): sum(error²), parameters, JtJ, Jty

     T←{                                                ⍝ try guess(λ)
         r⊢←0 ⋄ 11::dx⌊⍵×di ⋄ b←1-÷1⌈d⊢←D ⍵             ⍝     bad guess if domain error
         ∆p←jy⌹jj+⍺×⍤1⊢⍵×dj←(⎕CT+b-⎕CT×b)⌈1 1⍉jj        ⍝     change of parameters with adaptive floor
         s0←2÷⍨∆p+.×jy+∆p×⍵×dj                          ⍝     predicted error decrement
         s1←s-⊃g←E⊢q←p-∆p                               ⍝     actual error decrement
         r⊢←(p(-÷⍥(+.×⍨)⊣)q)⌊|s1÷s                      ⍝     relative change in parameters or residuals
         (⎕CT>s0)∧⎕CT<s1:dx⌊⍵×di                        ⍝     if no changing, increase damping
         (⎕CT≤s0)∧tg≥s1÷s0:dx⌊⍵×di                      ⍝     if diverging, increase damping
         dn⌈⍵×dd⊣s p jj jy⊢←A g                         ⍝     accept change, decrease damping
     }
     C←⍵⍵{                                              ⍝ convergence check(λ_prev, λ)
         _←⍺⍺(i⊢←i+1)s r d p                            ⍝     call user function
         (ti<i)∨(dx∧.=⍺ ⍵)∨(ts>s)∨(r>0)∧tr>r            ⍝     iterations, max damping, residual, not changing
     }
     i r←0 ⋄ _←⍵⍵ i s r d p⊣s p jj jy←A E p             ⍝ init
     i s r d p⊣(∘.=⍨⍳≢p)T⍣C{11::dx ⋄ D⍣¯1⊢⍵}d           ⍝ return iterations, ssr, change, norm damping, parameters
 }
